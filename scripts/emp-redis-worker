#!/bin/bash
### BEGIN INIT INFO
# Provides:          emp-redis-worker
# Required-Start:    $network $local_fs
# Required-Stop:     $network $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start EmProps Redis Worker for a specific GPU
### END INIT INFO

# Paths
ROOT="${ROOT:-/workspace}"
LOG_DIR="${ROOT}/logs"
MAIN_LOG="${LOG_DIR}/start.log"

# Source environment variables (ensure NUM_GPUS is available if needed, though not directly used here)
if [ -f /etc/environment ]; then
    while IFS='=' read -r key value; do
        if [ -n "$key" ]; then
            key=$(echo "$key" | tr -d '"' | xargs)
            value=$(echo "$value" | tr -d '"' | xargs)
            export "$key=$value"
        fi
    done < /etc/environment
fi

# Logging setup specific to this service instance
log() {
    local GPU_NUM=$1
    shift
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local msg="[Worker GPU${GPU_NUM}] $*"
    local log_line="[$timestamp] $msg"
    local WORKER_LOG_DIR="${ROOT}/worker_gpu${GPU_NUM}/logs"
    local WORKER_LOG_FILE="${WORKER_LOG_DIR}/output.log"

    # Write to main start log if possible
    if [ -w "$MAIN_LOG" ]; then
        echo "$log_line" >> "$MAIN_LOG"
    fi

    # Write to specific worker log file
    mkdir -p "$WORKER_LOG_DIR"
    touch "$WORKER_LOG_FILE"
    echo "$log_line" >> "$WORKER_LOG_FILE"

    # Always echo to stdout for Docker logs
    echo "$msg"
}

# Get PID of the running service
get_pid() {
    local GPU_NUM=$1
    local PID_FILE="${ROOT}/worker_gpu${GPU_NUM}/worker.pid"
    if [ -f "$PID_FILE" ]; then
        cat "$PID_FILE"
    fi
}

# Check if service is running
is_running() {
    local GPU_NUM=$1
    local PID=$(get_pid "$GPU_NUM")
    if [ -n "$PID" ]; then
        if kill -0 "$PID" 2>/dev/null; then
            return 0 # Running
        fi
    fi
    return 1 # Not running
}

start() {
    local GPU_NUM=$1
    local WORKER_DIR="${ROOT}/worker_gpu${GPU_NUM}"
    local PID_FILE="${WORKER_DIR}/worker.pid"
    local LOG_FILE="${WORKER_DIR}/logs/output.log"

    log "$GPU_NUM" "Attempting to start service..."

    if is_running "$GPU_NUM"; then
        log "$GPU_NUM" "Service is already running (PID: $(get_pid "$GPU_NUM"))"
        return 0
    fi

    # Ensure worker directory and script exist
    if [ ! -d "$WORKER_DIR" ]; then
        log "$GPU_NUM" "ERROR: Working directory $WORKER_DIR does not exist"
        return 1
    fi
    if [ ! -f "${WORKER_DIR}/worker/worker.py" ]; then
        log "$GPU_NUM" "ERROR: worker/worker.py not found in $WORKER_DIR"
        return 1
    fi
     # Ensure .env file exists
    if [ ! -f "${WORKER_DIR}/.env" ]; then
        log "$GPU_NUM" "ERROR: .env file not found in $WORKER_DIR"
        return 1
    fi

    log "$GPU_NUM" "Starting Redis Worker service for GPU $GPU_NUM"
    cd "$WORKER_DIR" || {
        log "$GPU_NUM" "ERROR: Failed to cd into $WORKER_DIR"
        return 1
    }

    # Command to start the worker
    local CMD_WORKER="python worker/worker.py"

    # Set environment and run
    log "$GPU_NUM" "Running command: CUDA_VISIBLE_DEVICES=$GPU_NUM $CMD_WORKER"
    export CUDA_VISIBLE_DEVICES=$GPU_NUM
    PYTHONUNBUFFERED=1 eval "$CMD_WORKER" >> "$LOG_FILE" 2>&1 &
    local PID=$!

    if [ $? -ne 0 ]; then
         log "$GPU_NUM" "ERROR: Failed to start worker process."
         return 1
    fi
    
    echo $PID > "$PID_FILE"
    log "$GPU_NUM" "Service started with PID $PID"

    # Brief wait and check
    sleep 2
    if ! is_running "$GPU_NUM"; then
        log "$GPU_NUM" "ERROR: Service failed to stay running after start. Check logs: $LOG_FILE"
        rm -f "$PID_FILE"
        return 1
    fi

    log "$GPU_NUM" "Service started successfully"
    return 0
}

stop() {
    local GPU_NUM=$1
    local WORKER_DIR="${ROOT}/worker_gpu${GPU_NUM}"
    local PID_FILE="${WORKER_DIR}/worker.pid"

    log "$GPU_NUM" "Attempting to stop service..."

    if [ ! -f "$PID_FILE" ]; then
        log "$GPU_NUM" "PID file not found. Service might not be running or was stopped uncleanly."
        # Check if process is somehow running without PID file
         # This part is tricky without a port; relying on PID file mainly
        return 0 
    fi

    local PID=$(cat "$PID_FILE")
    if [ -z "$PID" ]; then
         log "$GPU_NUM" "PID file is empty."
         rm -f "$PID_FILE"
         return 0
    fi

    if kill -0 "$PID" 2>/dev/null; then
        log "$GPU_NUM" "Stopping service (PID: $PID)"
        kill "$PID"
        sleep 2
        # Force kill if still running
        if kill -0 "$PID" 2>/dev/null; then
             log "$GPU_NUM" "Service did not stop gracefully, sending SIGKILL..."
             kill -9 "$PID"
             sleep 1
        fi
         log "$GPU_NUM" "Service stopped."
    else
        log "$GPU_NUM" "Process with PID $PID not found. Already stopped?"
    fi

    rm -f "$PID_FILE"
    log "$GPU_NUM" "Service stop procedure complete."
    return 0
}

status() {
    local GPU_NUM=$1
    if is_running "$GPU_NUM"; then
        log "$GPU_NUM" "Service is running (PID: $(get_pid "$GPU_NUM"))"
        return 0
    else
        log "$GPU_NUM" "Service is stopped"
        return 1 # Use LSB convention (0=running, 1=stopped/error, 3=stopped)
    fi
}

restart() {
    local GPU_NUM=$1
    log "$GPU_NUM" "Attempting to restart service..."
    stop "$GPU_NUM"
    sleep 1
    start "$GPU_NUM"
}

# Script execution logic
case "$1" in
    start|stop|status|restart)
        if [ -z "$2" ]; then
            echo "Usage: $0 {start|stop|status|restart} <gpu_id>"
            exit 1
        fi
        GPU_ID="$2"
        # Basic validation
        if ! [[ "$GPU_ID" =~ ^[0-9]+$ ]]; then
           echo "Error: Invalid GPU ID '$GPU_ID'. Must be a number."
           exit 1
        fi
        "$1" "$GPU_ID"
        exit $?
        ;;
    *)
        echo "Usage: $0 {start|stop|status|restart} <gpu_id>"
        exit 1
        ;;
esac
