#!/bin/bash

# Base directory for your ComfyUI instances
ROOT="${ROOT:-/workspace}"
LOG_DIR="${ROOT}/logs"
START_LOG="${LOG_DIR}/start.log"

# Ensure log directory exists
mkdir -p "$LOG_DIR"
chmod 755 "$LOG_DIR"
touch "$START_LOG"
chmod 644 "$START_LOG"

# Source environment variables
if [ -f /etc/environment ]; then
    while IFS='=' read -r key value; do
        if [ -n "$key" ]; then
            # Remove any leading/trailing whitespace and quotes
            key=$(echo "$key" | tr -d '"' | xargs)
            value=$(echo "$value" | tr -d '"' | xargs)
            export "$key=$value"
        fi
    done < /etc/environment
fi

log() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local msg="[MGPU] $*"
    
    # Ensure log directory exists
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
        chmod 755 "$LOG_DIR"
    fi
    
    # Ensure log file exists and is writable
    if [ ! -f "$START_LOG" ]; then
        touch "$START_LOG"
        chmod 644 "$START_LOG"
    fi
    
    if [ -w "$START_LOG" ]; then
        echo "[$timestamp] $msg" | tee -a "$START_LOG" >&2
    else
        echo "[$timestamp] $msg (Warning: Could not write to $START_LOG)" >&2
    fi
}

# Test logging at startup
log "MGPU script starting, log file: $START_LOG"

# Add debug logging at start (only once)
if [ "${DEBUG:-}" = "true" ]; then
    log "Debug: Environment variables at script start:"
    log "NUM_GPUS=${NUM_GPUS:-not set}"
    log "ROOT=$ROOT"
    log "PATH=$PATH"
    log "MOCK_GPU=${MOCK_GPU:-not set}"
fi

# Validate GPU ID
validate_gpu_id() {
    local gpu_id=$1

    # Special case for 'all'
    if [ "$gpu_id" = "all" ]; then
        [ "${DEBUG:-}" = "true" ] && log "Debug: Validating GPU ID: all"
        return 0
    fi

    # Check if gpu_id is a number
    if ! [[ "$gpu_id" =~ ^[0-9]+$ ]]; then
        log "Error: Invalid GPU ID '$gpu_id'. Must be a number or 'all'"
        return 1
    fi

    [ "${DEBUG:-}" = "true" ] && log "Debug: Validating GPU ID: $gpu_id"
    [ "${DEBUG:-}" = "true" ] && log "Debug: Current NUM_GPUS value: $NUM_GPUS"

    # Check if gpu_id is within range
    if [ "$gpu_id" -ge "${NUM_GPUS:-0}" ]; then
        log "Error: GPU ID '$gpu_id' is out of range. Must be between 0 and $((NUM_GPUS-1))"
        return 1
    fi

    return 0
}

# Function to show logs
show_logs() {
    # 2025-04-12 16:50: Updated to require service specification
    local service_type=$1
    local gpu_id=$2
    shift 2  # Remove service_type and gpu_id from arguments
    
    # Validate service type
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    # Check if multitail is available
    if ! command -v multitail >/dev/null 2>&1; then
        log "ERROR: multitail is not installed. Please install it first."
        return 1
    fi

    # Define colors for each GPU
    local colors=("green" "yellow" "blue" "magenta" "cyan" "red" "white" "purple")
    
    # Determine the directory prefix based on service type
    local dir_prefix
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" = "comfyui" ]; then
        dir_prefix="comfyui_gpu"
    else
        dir_prefix="a1111_gpu"
    fi
    
    # If only one GPU is specified, use tail instead of multitail
    if [ "$gpu_id" != "all" ]; then
        # Validate GPU number
        if ! [[ "$gpu_id" =~ ^[0-9]+$ ]]; then
            log "Error: Invalid GPU ID '$gpu_id'"
            return 1
        fi
        
        # Validate GPU ID
        validate_gpu_id "$gpu_id" >/dev/null || return 1
        
        local log_file="${ROOT}/${dir_prefix}${gpu_id}/logs/output.log"
        if [ -f "$log_file" ]; then
            # Check if no-follow mode is requested
            if [ "$1" = "-n" ] || [ "$1" = "no-follow" ]; then
                log "Showing recent logs for $service_type on GPU $gpu_id"
                tail -n 100 "$log_file"
            else
                log "Starting log view for $service_type on GPU $gpu_id (Ctrl+C to exit)"
                tail -f "$log_file"
            fi
            return 0
        else
            log "ERROR: Log file not found for $service_type on GPU $gpu_id"
            return 1
        fi
    fi
    
    # For 'all', use multitail
    # Build the multitail command
    local cmd="multitail --mergeall -m 5000"  # 5000 lines of scroll buffer
    local found_valid=false
    local gpu_count
    gpu_count=$(show_count)
    
    # Show all available GPUs
    for ((i=0; i<gpu_count; i++)); do
        local log_file="${ROOT}/${dir_prefix}${i}/logs/output.log"
        if [ -f "$log_file" ]; then
            local color_index=$((i % ${#colors[@]}))
            cmd="$cmd -ci ${colors[$color_index]} --label \"$service_type GPU$i: \" $log_file"
            found_valid=true
        fi
    done
    
    if [ "$found_valid" = "false" ]; then
        log "ERROR: No valid $service_type GPU logs found"
        return 1
    fi
    
    # Execute the multitail command
    log "Starting log view for all $service_type services (Press 'b' to scroll, 'q' to exit scroll mode, Ctrl+C to exit)"
    eval "$cmd"
}

# Function to start a specific GPU service
start_service() {
    local service_type=$1
    local gpu_id=$2
    
    # 2025-04-12 16:40: Updated to require service specification
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # Validate service type
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    if [ "$gpu_id" = "all" ]; then
        start_all_services "$service_type"
        return $?
    fi
    
    log "Starting $service_type service for GPU $gpu_id..."
    # Pass test_gpus as third parameter if MOCK_GPU is set
    if [ "${MOCK_GPU:-0}" -eq 1 ]; then
        service "$service_type" start "$gpu_id" "1" || return 1
    else
        service "$service_type" start "$gpu_id" || return 1
    fi
}

# Function to start all GPU services
start_all_services() {
    # 2025-04-12 16:41: Updated to support service type parameter
    local service_type=$1
    
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    log "Starting all $service_type services..."
    local gpu_count
    gpu_count=$(show_count)
    
    for ((i=0; i<gpu_count; i++)); do
        start_service "$service_type" "$i"
    done
    
    log "All $service_type services started"
    return 0
}

# Function to stop a specific GPU service
stop_service() {
    # 2025-04-12 16:42: Updated to require service specification
    local service_type=$1
    local gpu_id=$2
    
    # Validate service type
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    if [ "$gpu_id" = "all" ]; then
        stop_all_services "$service_type"
        return
    fi
    
    # Validate GPU ID first (only once)
    validate_gpu_id "$gpu_id" >/dev/null || return 1
    
    log "Stopping $service_type service for GPU $gpu_id..."
    service "$service_type" stop "$gpu_id"
}

# Internal function to stop a service
stop_service_internal() {
    # 2025-04-12 16:42: Updated to require service specification
    local service_type=$1
    local gpu_id=$2
    service "$service_type" stop "$gpu_id"
}

# Function to stop all GPU services
stop_all_services() {
    # 2025-04-12 16:42: Updated to require service specification
    local service_type=$1
    
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    log "Stopping all $service_type services..."
    local failed=0
    local gpu_count
    gpu_count=$(show_count)
    
    for ((i=0; i<gpu_count; i++)); do
        if ! stop_service "$service_type" "$i"; then
            failed=1
        fi
    done
    
    log "All $service_type services stopped"
    return $failed
}

## Function to restart a specific GPU service
restart_service() {
    # 2025-04-12 16:43: Updated to require service specification
    local service_type=$1
    local gpu_id=$2
    
    # Validate service type
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    if [ "$gpu_id" = "all" ]; then
        restart_all_services "$service_type"
        return
    fi
    
    # Validate GPU ID first (only once)
    validate_gpu_id "$gpu_id" >/dev/null || return 1
    
    log "Restarting $service_type service for GPU $gpu_id..."
    service "$service_type" restart "$gpu_id"
}

# Function to restart all GPU services
restart_all_services() {
    # 2025-04-12 16:43: Updated to require service specification
    local service_type=$1
    
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    log "Restarting all $service_type services..."
    local failed=0
    local gpu_count
    gpu_count=$(show_count)
    
    for ((i=0; i<gpu_count; i++)); do
        if ! restart_service "$service_type" "$i"; then
            failed=1
        fi
    done
    return $failed
}

# Function to check status of a specific GPU service
check_status() {
    # 2025-04-12 16:45: Updated to require service specification
    local service_type=$1
    local gpu_id=$2
    
    # Validate service type
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    if [ "$gpu_id" = "all" ]; then
        check_all_status "$service_type"
        return $?
    fi
    
    # Validate GPU ID first (only once)
    validate_gpu_id "$gpu_id" >/dev/null || return 1
    
    # Capture the output of service status
    local status_output
    status_output=$(service "$service_type" status "$gpu_id" 2>&1)
    local exit_code=$?
    
    # Extract status from the output (matches "Service is running" or "Service is not running")
    if echo "$status_output" | grep -q "Service is running"; then
        printf "%s GPU %d: %s\n" "$service_type" "$gpu_id" "$(echo "$status_output" | grep "Service is" | sed "s/\[.*\] //")"
        return 0
    else
        printf "%s GPU %d: %s\n" "$service_type" "$gpu_id" "$(echo "$status_output" | grep "Service is" | sed "s/\[.*\] //")"
        return $exit_code
    fi
}

# Function to check status of all GPU services
check_all_status() {
    # 2025-04-12 16:45: Updated to require service specification
    local service_type=$1
    
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    log "Checking status of all $service_type services..."
    local failed=0
    local gpu_count
    gpu_count=$(show_count)
    
    for ((i=0; i<gpu_count; i++)); do
        if ! check_status "$service_type" "$i"; then
            failed=1
        fi
    done
    return $failed
}

# Function to setup a service (ComfyUI or Automatic1111) for a specific GPU or CPU
setup_gpu() {
    # 2025-04-12 16:47: Updated to support both ComfyUI and Automatic1111
    local service_type=$1
    local gpu_id=$2
    local target_dir
    
    # Validate service type
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" != "comfyui" ] && [ "$service_type" != "a1111" ]; then
        log "ERROR: Invalid service type: $service_type. Must be 'comfyui' or 'a1111'"
        return 1
    fi
    
    if [ "$gpu_id" = "all" ]; then
        setup_all_gpus "$service_type"
        return $?
    fi
    
    # Set target directory based on service type
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" = "comfyui" ]; then
        target_dir="${ROOT}/comfyui_gpu${gpu_id}"
    else
        target_dir="${ROOT}/a1111_gpu${gpu_id}"
    fi
    
    log "Setting up $service_type for GPU ${gpu_id}..."
    
    # Create directory if it doesn't exist
    mkdir -p "$target_dir"
    chmod 755 "$target_dir"
    
    # Setup based on service type
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    if [ "$service_type" = "comfyui" ]; then
        setup_comfyui "$gpu_id" "$target_dir"
    else
        setup_a1111 "$gpu_id" "$target_dir"
    fi
    
    return $?
}

# Function to setup ComfyUI for a specific GPU
setup_comfyui() {
    local gpu_id=$1
    local target_dir=$2
    
    # Use COMFY_REPO_URL environment variable with fallback
    local repo_url="${COMFY_REPO_URL:-https://github.com/comfyanonymous/ComfyUI.git}"
    local base_commit="0c04a6ae780b5eefb1a701467439ae1235607a4f"
    
    log "Cloning ComfyUI from ${repo_url} for GPU ${gpu_id}..."
    if ! git clone "$repo_url" "$target_dir"; then
        log "ERROR: Failed to clone ComfyUI"
        return 1
    fi
    
    cd "$target_dir" || return 1
    
    # Handle different branches based on whether it's a fork
    if [ "$repo_url" = "https://github.com/stakeordie/ComfyUI.git" ]; then
        log "Fork detected, checking out websocket_version branch..."
        if ! git checkout websocket_version; then
            log "ERROR: Failed to checkout websocket_version branch"
            return 1
        fi
    else
        log "Base repo detected, resetting to specific commit ${base_commit}..."
        if ! git reset --hard "$base_commit"; then
            log "ERROR: Failed to reset to specific commit"
            return 1
        fi
    fi
    cd - > /dev/null || return 1
    
    # Create logs directory
    mkdir -p "${target_dir}/logs"
    chmod 755 "${target_dir}/logs"
    touch "${target_dir}/logs/output.log"
    chmod 644 "${target_dir}/logs/output.log"
    
    # Verify setup
    if [ ! -f "${target_dir}/main.py" ]; then
        log "ERROR: Setup failed - main.py not found in $target_dir"
        return 1
    fi
    
    # Handle workflows directory
    if [ -d "${target_dir}/user/default/workflows" ]; then
        log "Removing existing workflows directory..."
        rm -rf "${target_dir}/user/default/workflows"
    fi
    
    if [ ! -d "${target_dir}/user/default" ]; then
        log "Creating user/default directory..."
        mkdir -p "${target_dir}/user/default"
    fi
    
    if [ ! -L "${target_dir}/user/default/workflows" ]; then
        log "Symlinking workflows directory..."
        ln -s "/workspace/shared/workflows" "${target_dir}/user/default/workflows"
    fi
    
    log "ComfyUI setup complete for GPU ${gpu_id}"
    return 0
}

# Function to setup Automatic1111 for a specific GPU
setup_a1111() {
    # 2025-04-14 20:40:00-04:00: Updated to use template approach instead of cloning
    local gpu_id=$1
    local target_dir=$2
    
    log "DEBUG: Setting up Automatic1111 for GPU ${gpu_id} in directory ${target_dir}"
    
    # Check if target directory exists
    if [ ! -d "$target_dir" ]; then
        log "Creating target directory: $target_dir"
        mkdir -p "$target_dir" || {
            log "ERROR: Failed to create directory $target_dir"
            return 1
        }
    fi
    
    # Check if directory is empty
    if [ "$(ls -A "$target_dir" 2>/dev/null)" ]; then
        log "Target directory $target_dir is not empty, using existing installation"
    else
        # Copy from template directory
        log "Copying Automatic1111 from template for GPU ${gpu_id}..."
        
        # [2025-04-15T10:04:50-04:00] Use /tmp/a1111_template as the new template source
        if [ -d "/tmp/a1111_template" ]; then
            log "Copying from template directory /tmp/a1111_template"
            # [2025-04-15T21:26:34-04:00] Use rsync instead of cp to include hidden files like .git
            rsync -a /tmp/a1111_template/ "$target_dir/" || {
                log "ERROR: Failed to copy from template directory"
                return 1
            }
            log "Successfully copied Automatic1111 template to $target_dir"
        else
            log "ERROR: Template directory /tmp/a1111_template not found"
            return 1
        fi
    fi
    
    # Create logs directory
    log "Creating logs directory in ${target_dir}/logs"
    mkdir -p "${target_dir}/logs" || {
        log "ERROR: Failed to create logs directory"
        return 1
    }
    chmod 755 "${target_dir}/logs"
    touch "${target_dir}/logs/output.log"
    chmod 644 "${target_dir}/logs/output.log"
    
    # Verify setup
    log "Verifying Automatic1111 setup..."
    if [ ! -f "${target_dir}/webui.py" ]; then
        log "ERROR: Setup failed - webui.py not found in $target_dir"
        log "DEBUG: Directory contents: $(ls -la "$target_dir")"
        return 1
    fi
    
    # Make webui.sh executable
    log "Making webui.sh executable..."
    if [ -f "${target_dir}/webui.sh" ]; then
        chmod +x "${target_dir}/webui.sh" || {
            log "WARNING: Failed to make webui.sh executable"
        }
    else
        log "WARNING: webui.sh not found in $target_dir"
    fi
    
    # Setup configuration symlinks
    # Added: 2025-04-14T20:45:00-04:00 - Setting up configuration symlinks
    log "Setting up configuration symlinks"
    
    # Create necessary directories
    mkdir -p /data/.cache /data/embeddings /data/config/auto /data/config/auto/extensions /data/config/auto/config_states
    
    # Define configuration symlinks
    declare -A CONFIG_SYMLINKS=(
        ["${target_dir}/config.json"]="/data/config/auto/config.json"
        ["${target_dir}/ui-config.json"]="/data/config/auto/ui-config.json"
        ["${target_dir}/styles.csv"]="/data/config/auto/styles.csv"
        ["${target_dir}/extensions"]="/data/config/auto/extensions"
        ["${target_dir}/config_states"]="/data/config/auto/config_states"
        ["${target_dir}/embeddings"]="/data/embeddings"
    )
    
    # Create configuration symlinks
    for link_target in "${!CONFIG_SYMLINKS[@]}"; do
        link_source="${CONFIG_SYMLINKS[$link_target]}"
        
        # Remove target if it exists
        if [ -e "$link_target" ]; then
            rm -rf "$link_target"
        fi
        
        # Create parent directory if needed
        mkdir -p "$(dirname "$link_target")"
        
        # Create source file/directory if it doesn't exist
        if [ ! -e "$link_source" ]; then
            if [[ "$link_source" == *".json" ]] || [[ "$link_source" == *".csv" ]]; then
                # For files, create empty file
                touch "$link_source"
            else
                # For directories, create directory
                mkdir -p "$link_source"
            fi
        fi
        
        # Create symlink
        ln -sf "$link_source" "$link_target"
        log "Created symlink: $link_target -> $link_source"
    done
    
    # [2025-04-17T13:33:51-04:00] Initialize configuration files with valid JSON
    log "Initializing configuration files with valid JSON"
    if [ -f "/scripts/a1111_scripts/a1111_config.py" ]; then
        python3 /scripts/a1111_scripts/a1111_config.py "/data/config/auto/config.json"
        python3 /scripts/a1111_scripts/a1111_config.py "/data/config/auto/ui-config.json"
        log "Configuration files initialized with valid JSON structure"
    else
        log "WARNING: a1111_config.py not found, configuration files may be empty"
    fi
    
    # [2025-04-15T10:04:50-04:00] Setting up shared a1111_models directory and symlink in worker
    SHARED_MODELS_DIR="/workspace/shared/a1111_models"
    mkdir -p "$SHARED_MODELS_DIR"
    # [2025-04-16T20:33:38-04:00] Ensure Stable-diffusion subdirectory exists
    mkdir -p "${SHARED_MODELS_DIR}/Stable-diffusion"
    log "Created directory: ${SHARED_MODELS_DIR}/Stable-diffusion"
    
    # Remove any models directory in the worker (if present)
    if [ -e "${target_dir}/models" ]; then
        rm -rf "${target_dir}/models"
    fi
    ln -sf "$SHARED_MODELS_DIR" "${target_dir}/models"
    log "Created symlink: ${target_dir}/models -> $SHARED_MODELS_DIR"
    
    # [2025-04-16T20:24:53-04:00] Check for models only in shared models directory
    # Removed unnecessary ComfyUI directory path as it never contains models
    COMFY_MODEL_DIRS=(
        "/workspace/shared/models/checkpoints"
    )
    
    MODELS_FOUND=false
    
    # Define the models we want to look for with their download URLs
    # Added: 2025-04-14T21:26:00-04:00 - Added model download URLs for individual downloads
    declare -A MODEL_URLS=(
        ["juggernautXL_v8Rundiffusion.safetensors"]="https://civitai.com/api/download/models/288982?type=Model&format=SafeTensor&size=full&fp=fp16"
        ["v1-5-pruned.safetensors"]="https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned.safetensors"
        ["v2-1_768-ema-pruned.safetensors"]="https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.safetensors"
        ["sd_xl_base_1.0_0.9vae.safetensors"]="https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_base_1.0_0.9vae.safetensors"
        ["sd_xl_refiner_1.0_0.9vae.safetensors"]="https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0/resolve/main/sd_xl_refiner_1.0_0.9vae.safetensors"
        ["v1-5-pruned.ckpt"]="https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned.ckpt"
        ["v2-1_768-ema-pruned.ckpt"]="https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.ckpt"
        ["sd_xl_base_1.0.safetensors"]="https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_base_1.0.safetensors"
        ["sd_xl_refiner_1.0.safetensors"]="https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0/resolve/main/sd_xl_refiner_1.0.safetensors"
    )
    
    # Added: 2025-04-14T21:29:00-04:00 - Define model name aliases (different capitalizations)
    declare -A MODEL_ALIASES=(
        ["JuggernautXL_v8Rundiffusion.safetensors"]="juggernautXL_v8Rundiffusion.safetensors"
    )
    
    # Set up a counter for downloaded models
    MODELS_DOWNLOADED=0
    
    # Process each model
    # Added: 2025-04-14T21:29:00-04:00 - Enhanced to handle model aliases and different capitalizations
    for model_name in "${!MODEL_URLS[@]}"; do
        MODEL_FOUND=false
        
        # Check if model exists in any of the ComfyUI model directories
        for comfy_dir in "${COMFY_MODEL_DIRS[@]}"; do
            if [ -f "${comfy_dir}/${model_name}" ]; then
                log "Found model ${model_name} in ${comfy_dir}, creating symlink"
                # [2025-04-16T20:34:27-04:00] Updated to use SHARED_MODELS_DIR instead of target_dir/models
                if ! ln -sf "${comfy_dir}/${model_name}" "${SHARED_MODELS_DIR}/Stable-diffusion/${model_name}"; then
                    log "ERROR: Failed to create symlink for ${model_name}"
                else
                    log "Successfully created symlink: ${SHARED_MODELS_DIR}/Stable-diffusion/${model_name} -> ${comfy_dir}/${model_name}"
                    MODEL_FOUND=true
                fi
                MODELS_FOUND=true
                break
            fi
        done
        
        # If model not found in ComfyUI directories, download it
        if [ "$MODEL_FOUND" = "false" ]; then
            # [2025-04-15T09:44:38-04:00] Block downloads if STORAGE_TEST_MODE=true
            if [ "${STORAGE_TEST_MODE:-false}" = "true" ]; then
                log "[TEST MODE] STORAGE_TEST_MODE=true: Skipping download of missing model ${model_name}. No download will be attempted."
                continue
            fi
            log "Model ${model_name} not found in ComfyUI directories, attempting to download"
            
            # Get the download URL
            download_url="${MODEL_URLS[$model_name]}"
            target_file="${target_dir}/models/Stable-diffusion/${model_name}"
            
            # Download the model
            log "Downloading ${model_name} from ${download_url}"
            if curl -L -o "$target_file" "$download_url" --progress-bar; then
                log "Successfully downloaded ${model_name}"
                MODELS_FOUND=true
                MODELS_DOWNLOADED=$((MODELS_DOWNLOADED + 1))
            else
                log "WARNING: Failed to download ${model_name}"
            fi
        fi
    done
    
    # Process model aliases (different capitalizations)
    for alias_name in "${!MODEL_ALIASES[@]}"; do
        original_name="${MODEL_ALIASES[$alias_name]}"
        target_file="${target_dir}/models/Stable-diffusion/${original_name}"
        alias_file="${target_dir}/models/Stable-diffusion/${alias_name}"
        
        # If the original model exists, create a symlink with the alias name
        if [ -f "$target_file" ]; then
            log "Creating alias symlink: ${alias_name} -> ${original_name}"
            ln -sf "$target_file" "$alias_file"
        else
            # Check if the alias exists in ComfyUI directories
            ALIAS_FOUND=false
            
            for comfy_dir in "${COMFY_MODEL_DIRS[@]}"; do
                if [ -f "${comfy_dir}/${alias_name}" ]; then
                    log "Found alias model ${alias_name} in ${comfy_dir}, creating symlinks"
                    ln -sf "${comfy_dir}/${alias_name}" "$alias_file"
                    ln -sf "${comfy_dir}/${alias_name}" "$target_file"
                    ALIAS_FOUND=true
                    MODELS_FOUND=true
                    break
                fi
            done
            
            if [ "$ALIAS_FOUND" = "false" ]; then
                log "Alias model ${alias_name} not found, skipping"
            fi
        fi
    done
    
    log "Downloaded $MODELS_DOWNLOADED models that weren't found locally"
    
    # If no models were found, clone the repo
    # Added: 2025-04-14T20:45:00-04:00 - Added model repository cloning as fallback
    if [ "${STORAGE_TEST_MODE:-false}" = "false" ]; then
        log "No models found in ComfyUI directories, cloning sd_models repo"
        
        # Install git-lfs if not already installed
        if ! command -v git-lfs &> /dev/null; then
            log "Installing git-lfs"
            apt-get update && apt-get install -y git-lfs
            git lfs install
        fi
        
        # Clone the models repo
        log "Cloning sd_models repo"
        git clone https://github.com/stakeordie/sd_models.git /tmp/emprops_models_repo
        rm -rf /tmp/emprops_models_repo/.git
        
        # Copy models to the shared a1111_models directory
        log "Copying models to /workspace/shared/a1111_models"
        rsync -avz --progress /tmp/emprops_models_repo/ "/workspace/shared/a1111_models/"
        
        # Clean up
        rm -rf /tmp/emprops_models_repo
    fi
    
    log "Automatic1111 setup complete for GPU ${gpu_id}"
    return 0
}

# Function to create symbolic links based on YAML configuration
create_symbolic_links_from_yaml() {
    # 2025-04-13 21:05: Updated function to create symbolic links for contents of directories
    local target_dir=$1
    local config_file="${ROOT}/shared/a1111_dir_config.yaml"
    
    # Check if config file exists
    if [ ! -f "$config_file" ]; then
        log "ERROR: Configuration file $config_file not found"
        return 1
    fi
    
    log "Using configuration file: $config_file"
    
    # Use Python to parse the YAML file and generate symbolic link commands
    python3 -c "
# 2025-04-13 21:05: Python script to parse YAML configuration and create symbolic links for contents of directories
import yaml
import os
import sys
import glob

try:
    # Load YAML configuration
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f)
    
    # Get automatic1111 configuration
    a1111_config = config.get('automatic1111', {})
    if not a1111_config:
        print('ERROR: No automatic1111 configuration found in $config_file')
        sys.exit(1)
    
    # Get base path
    base_path = a1111_config.get('base_path', '/workspace/shared')
    
    # Process model directories
    models_config = a1111_config.get('models', {})
    for model_type, mapping in models_config.items():
        if '->' in mapping:
            source_path, target_path = mapping.split('->')
            source_path = source_path.strip()
            target_path = target_path.strip()
            
            # Create full paths
            full_source_path = os.path.join(base_path, source_path)
            full_target_path = os.path.join('$target_dir', target_path)
            
            # Remove trailing slashes for consistency
            if full_source_path.endswith('/'):
                full_source_path = full_source_path[:-1]
            if full_target_path.endswith('/'):
                full_target_path = full_target_path[:-1]
            
            # Create the target directory if it doesn't exist
            print(f'mkdir -p "{full_target_path}"')
            
            # Find all files in the source directory
            source_files = glob.glob(f'{full_source_path}/*')
            if not source_files:
                print(f'WARNING: No files found in {full_source_path}')
                continue
                
            # Create symbolic links for each file in the source directory
            for source_file in source_files:
                file_name = os.path.basename(source_file)
                target_file = os.path.join(full_target_path, file_name)
                
                # Remove existing file if it exists
                print(f'rm -f "{target_file}"')
                
                # Create symbolic link for the file
                print(f'ln -sf "{source_file}" "{target_file}"')
    
    # Process other directories
    directories_config = a1111_config.get('directories', {})
    for dir_type, mapping in directories_config.items():
        if '->' in mapping:
            source_path, target_path = mapping.split('->')
            source_path = source_path.strip()
            target_path = target_path.strip()
            
            # Create full paths
            full_source_path = os.path.join(base_path, source_path)
            full_target_path = os.path.join('$target_dir', target_path)
            
            # Remove trailing slashes for consistency
            if full_source_path.endswith('/'):
                full_source_path = full_source_path[:-1]
            if full_target_path.endswith('/'):
                full_target_path = full_target_path[:-1]
            
            # Create the target directory if it doesn't exist
            print(f'mkdir -p "{full_target_path}"')
            
            # Find all files in the source directory
            source_files = glob.glob(f'{full_source_path}/*')
            if not source_files:
                print(f'WARNING: No files found in {full_source_path}')
                continue
                
            # Create symbolic links for each file in the source directory
            for source_file in source_files:
                file_name = os.path.basename(source_file)
                target_file = os.path.join(full_target_path, file_name)
                
                # Remove existing file if it exists
                print(f'rm -f "{target_file}"')
                
                # Create symbolic link for the file
                print(f'ln -sf "{source_file}" "{target_file}"')
            
except Exception as e:
    print(f'ERROR: Failed to parse YAML configuration: {str(e)}')
    sys.exit(1)
" | while read -r cmd; do
        if [[ "$cmd" == ERROR:* ]]; then
            log "$cmd"
            return 1
        elif [[ "$cmd" == WARNING:* ]]; then
            log "$cmd"
        else
            log "Executing: $cmd"
            eval "$cmd" || {
                log "ERROR: Failed to execute command: $cmd"
                # Continue even if a single command fails
                # return 1
            }
        fi
    done
    
    log "Symbolic links created successfully"
    return 0
}

# Function to setup all GPU directories
setup_all_gpus() {
    # 2025-04-12 16:48: Updated to require service specification
    local service_type=$1
    
    if [ -z "$service_type" ]; then
        # 2025-04-12 17:52: Updated service name from comfy to comfyui
        log "ERROR: Service type (comfyui or a1111) must be specified"
        return 1
    fi
    
    log "Setting up $service_type for all GPUs..."
    local failed=0
    local gpu_count
    gpu_count=$(show_count)
    
    for ((i=0; i<gpu_count; i++)); do
        setup_gpu "$service_type" "$i" || failed=1
    done
    return $failed
}

# Show usage information
show_usage() {
    # 2025-04-12 16:48: Updated to include service type in usage
    cat << EOF
Usage: $0 SERVICE COMMAND [gpu_id] [options]

Services:
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    comfyui                ComfyUI service
    a1111                 Automatic1111 service

Commands:
    start   [gpu_id]       Start service for GPU
    stop    [gpu_id]       Stop service for GPU
    restart [gpu_id]       Restart service for GPU
    status  [gpu_id]       Show status of service for GPU
    logs    [gpu_id] [-n]  Show logs for GPU (default: follow mode, -n for no-follow)
    setup   [gpu_id]       Setup service for GPU
    count                  Show number of available GPUs

Arguments:
    gpu_id                 GPU ID (0-N) or 'all' for all GPUs
    
Options:
    -n, no-follow         For logs: show recent logs and exit (default: follow mode)

Examples:
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    $0 comfyui start 0      Start ComfyUI on GPU 0
    $0 a1111 start all     Start Automatic1111 on all GPUs
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    $0 comfyui logs 0       Follow ComfyUI logs for GPU 0
    $0 a1111 logs all      Follow Automatic1111 logs for all GPUs
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    $0 comfyui logs 0 -n    Show recent ComfyUI logs for GPU 0 and exit
EOF
}

# Function to show GPU count
show_count() {
    if [ "${MOCK_GPU:-0}" = "1" ]; then
        echo "${NUM_GPUS}"
    else
        # Try to get real GPU count from nvidia-smi
        if command -v nvidia-smi >/dev/null 2>&1; then
            nvidia-smi --query-gpu=gpu_name --format=csv,noheader | wc -l
        else
            echo "0"
        fi
    fi
}

# Main command handling
# 2025-04-12 16:48: Updated to require service type as first parameter
if [ -z "$1" ]; then
    show_usage
    exit 1
fi

case "$1" in
    # 2025-04-12 17:52: Updated service name from comfy to comfyui
    comfyui|a1111)
        service_type="$1"
        shift  # Remove service type from arguments
        
        if [ -z "$1" ]; then
            show_usage
            exit 1
        fi
        
        case "$1" in
            start|stop|restart|status|setup)
                if [ -z "$2" ]; then
                    show_usage
                    exit 1
                fi
                
                case "$1" in
                    start)
                        start_service "$service_type" "$2"
                        ;;
                    stop)
                        stop_service "$service_type" "$2"
                        ;;
                    restart)
                        restart_service "$service_type" "$2"
                        ;;
                    status)
                        check_status "$service_type" "$2"
                        ;;
                    setup)
                        setup_gpu "$service_type" "$2"
                        ;;
                esac
                ;;
            logs)
                if [ -z "$2" ]; then
                    show_logs "$service_type" "all"
                else
                    gpu_id="$2"
                    shift 2  # Remove 'logs' and gpu_id from arguments
                    show_logs "$service_type" "$gpu_id" "$@"  # Pass all remaining arguments to show_logs
                fi
                ;;
            count)
                show_count
                ;;
            *)
                show_usage
                exit 1
                ;;
        esac
        ;;
    count)
        show_count
        ;;
    *)
        show_usage
        exit 1
        ;;
esac